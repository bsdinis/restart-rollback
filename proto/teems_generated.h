// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEEMS_TEEMS_H_
#define FLATBUFFERS_GENERATED_TEEMS_TEEMS_H_

#include "flatbuffers/flatbuffers.h"

namespace teems {

struct Value;

struct Policy;

struct GetArgs;
struct GetArgsBuilder;

struct GetResult;
struct GetResultBuilder;

struct GetTimestampArgs;
struct GetTimestampArgsBuilder;

struct GetTimestampResult;
struct GetTimestampResultBuilder;

struct ProxyGetArgs;
struct ProxyGetArgsBuilder;

struct ProxyPutArgs;
struct ProxyPutArgsBuilder;

struct PutArgs;
struct PutArgsBuilder;

struct PutResult;
struct PutResultBuilder;

struct ChangePolicyResult;
struct ChangePolicyResultBuilder;

struct SmrPropose;
struct SmrProposeBuilder;

struct SmrAccept;
struct SmrAcceptBuilder;

struct SmrReject;
struct SmrRejectBuilder;

struct StabilizeArgs;
struct StabilizeArgsBuilder;

struct Greeting;
struct GreetingBuilder;

struct Empty;
struct EmptyBuilder;

struct Message;
struct MessageBuilder;

enum MessageType : int8_t {
  MessageType_client_greeting = 0,
  MessageType_proxy_get_req = 1,
  MessageType_proxy_get_resp = 2,
  MessageType_proxy_put_req = 3,
  MessageType_proxy_put_resp = 4,
  MessageType_get_req = 5,
  MessageType_get_resp = 6,
  MessageType_get_timestamp_req = 7,
  MessageType_get_timestamp_resp = 8,
  MessageType_change_policy_req = 9,
  MessageType_change_policy_resp = 10,
  MessageType_put_req = 11,
  MessageType_put_resp = 12,
  MessageType_ping_req = 13,
  MessageType_ping_resp = 14,
  MessageType_reset_req = 15,
  MessageType_reset_resp = 16,
  MessageType_smr_propose = 17,
  MessageType_smr_accept = 18,
  MessageType_smr_reject = 19,
  MessageType_stabilize_req = 20,
  MessageType_close_req = 21,
  MessageType_MIN = MessageType_client_greeting,
  MessageType_MAX = MessageType_close_req
};

inline const MessageType (&EnumValuesMessageType())[22] {
  static const MessageType values[] = {
    MessageType_client_greeting,
    MessageType_proxy_get_req,
    MessageType_proxy_get_resp,
    MessageType_proxy_put_req,
    MessageType_proxy_put_resp,
    MessageType_get_req,
    MessageType_get_resp,
    MessageType_get_timestamp_req,
    MessageType_get_timestamp_resp,
    MessageType_change_policy_req,
    MessageType_change_policy_resp,
    MessageType_put_req,
    MessageType_put_resp,
    MessageType_ping_req,
    MessageType_ping_resp,
    MessageType_reset_req,
    MessageType_reset_resp,
    MessageType_smr_propose,
    MessageType_smr_accept,
    MessageType_smr_reject,
    MessageType_stabilize_req,
    MessageType_close_req
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[23] = {
    "client_greeting",
    "proxy_get_req",
    "proxy_get_resp",
    "proxy_put_req",
    "proxy_put_resp",
    "get_req",
    "get_resp",
    "get_timestamp_req",
    "get_timestamp_resp",
    "change_policy_req",
    "change_policy_resp",
    "put_req",
    "put_resp",
    "ping_req",
    "ping_resp",
    "reset_req",
    "reset_resp",
    "smr_propose",
    "smr_accept",
    "smr_reject",
    "stabilize_req",
    "close_req",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType_client_greeting, MessageType_close_req)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum BasicMessage : uint8_t {
  BasicMessage_NONE = 0,
  BasicMessage_ChangePolicyResult = 1,
  BasicMessage_Greeting = 2,
  BasicMessage_GetArgs = 3,
  BasicMessage_GetResult = 4,
  BasicMessage_GetTimestampArgs = 5,
  BasicMessage_GetTimestampResult = 6,
  BasicMessage_ProxyGetArgs = 7,
  BasicMessage_ProxyPutArgs = 8,
  BasicMessage_PutArgs = 9,
  BasicMessage_PutResult = 10,
  BasicMessage_SmrPropose = 11,
  BasicMessage_SmrAccept = 12,
  BasicMessage_SmrReject = 13,
  BasicMessage_StabilizeArgs = 14,
  BasicMessage_Empty = 15,
  BasicMessage_MIN = BasicMessage_NONE,
  BasicMessage_MAX = BasicMessage_Empty
};

inline const BasicMessage (&EnumValuesBasicMessage())[16] {
  static const BasicMessage values[] = {
    BasicMessage_NONE,
    BasicMessage_ChangePolicyResult,
    BasicMessage_Greeting,
    BasicMessage_GetArgs,
    BasicMessage_GetResult,
    BasicMessage_GetTimestampArgs,
    BasicMessage_GetTimestampResult,
    BasicMessage_ProxyGetArgs,
    BasicMessage_ProxyPutArgs,
    BasicMessage_PutArgs,
    BasicMessage_PutResult,
    BasicMessage_SmrPropose,
    BasicMessage_SmrAccept,
    BasicMessage_SmrReject,
    BasicMessage_StabilizeArgs,
    BasicMessage_Empty
  };
  return values;
}

inline const char * const *EnumNamesBasicMessage() {
  static const char * const names[17] = {
    "NONE",
    "ChangePolicyResult",
    "Greeting",
    "GetArgs",
    "GetResult",
    "GetTimestampArgs",
    "GetTimestampResult",
    "ProxyGetArgs",
    "ProxyPutArgs",
    "PutArgs",
    "PutResult",
    "SmrPropose",
    "SmrAccept",
    "SmrReject",
    "StabilizeArgs",
    "Empty",
    nullptr
  };
  return names;
}

inline const char *EnumNameBasicMessage(BasicMessage e) {
  if (flatbuffers::IsOutRange(e, BasicMessage_NONE, BasicMessage_Empty)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBasicMessage()[index];
}

template<typename T> struct BasicMessageTraits {
  static const BasicMessage enum_value = BasicMessage_NONE;
};

template<> struct BasicMessageTraits<teems::ChangePolicyResult> {
  static const BasicMessage enum_value = BasicMessage_ChangePolicyResult;
};

template<> struct BasicMessageTraits<teems::Greeting> {
  static const BasicMessage enum_value = BasicMessage_Greeting;
};

template<> struct BasicMessageTraits<teems::GetArgs> {
  static const BasicMessage enum_value = BasicMessage_GetArgs;
};

template<> struct BasicMessageTraits<teems::GetResult> {
  static const BasicMessage enum_value = BasicMessage_GetResult;
};

template<> struct BasicMessageTraits<teems::GetTimestampArgs> {
  static const BasicMessage enum_value = BasicMessage_GetTimestampArgs;
};

template<> struct BasicMessageTraits<teems::GetTimestampResult> {
  static const BasicMessage enum_value = BasicMessage_GetTimestampResult;
};

template<> struct BasicMessageTraits<teems::ProxyGetArgs> {
  static const BasicMessage enum_value = BasicMessage_ProxyGetArgs;
};

template<> struct BasicMessageTraits<teems::ProxyPutArgs> {
  static const BasicMessage enum_value = BasicMessage_ProxyPutArgs;
};

template<> struct BasicMessageTraits<teems::PutArgs> {
  static const BasicMessage enum_value = BasicMessage_PutArgs;
};

template<> struct BasicMessageTraits<teems::PutResult> {
  static const BasicMessage enum_value = BasicMessage_PutResult;
};

template<> struct BasicMessageTraits<teems::SmrPropose> {
  static const BasicMessage enum_value = BasicMessage_SmrPropose;
};

template<> struct BasicMessageTraits<teems::SmrAccept> {
  static const BasicMessage enum_value = BasicMessage_SmrAccept;
};

template<> struct BasicMessageTraits<teems::SmrReject> {
  static const BasicMessage enum_value = BasicMessage_SmrReject;
};

template<> struct BasicMessageTraits<teems::StabilizeArgs> {
  static const BasicMessage enum_value = BasicMessage_StabilizeArgs;
};

template<> struct BasicMessageTraits<teems::Empty> {
  static const BasicMessage enum_value = BasicMessage_Empty;
};

bool VerifyBasicMessage(flatbuffers::Verifier &verifier, const void *obj, BasicMessage type);
bool VerifyBasicMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Value FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_[128];

 public:
  Value()
      : data_() {
  }
  Value(flatbuffers::span<const uint8_t, 128> _data) {
    flatbuffers::CastToArray(data_).CopyFromSpan(_data);
  }
  const flatbuffers::Array<uint8_t, 128> *data() const {
    return &flatbuffers::CastToArray(data_);
  }
  flatbuffers::Array<uint8_t, 128> *mutable_data() {
    return &flatbuffers::CastToArray(data_);
  }
};
FLATBUFFERS_STRUCT_END(Value, 128);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Policy FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t policy_code_;
  int8_t padding0__;  int16_t padding1__;
  int32_t owner_id_;
  int64_t valid_from_;

 public:
  Policy()
      : policy_code_(0),
        padding0__(0),
        padding1__(0),
        owner_id_(0),
        valid_from_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  Policy(uint8_t _policy_code, int32_t _owner_id, int64_t _valid_from)
      : policy_code_(flatbuffers::EndianScalar(_policy_code)),
        padding0__(0),
        padding1__(0),
        owner_id_(flatbuffers::EndianScalar(_owner_id)),
        valid_from_(flatbuffers::EndianScalar(_valid_from)) {
    (void)padding0__;
    (void)padding1__;
  }
  uint8_t policy_code() const {
    return flatbuffers::EndianScalar(policy_code_);
  }
  void mutate_policy_code(uint8_t _policy_code) {
    flatbuffers::WriteScalar(&policy_code_, _policy_code);
  }
  int32_t owner_id() const {
    return flatbuffers::EndianScalar(owner_id_);
  }
  void mutate_owner_id(int32_t _owner_id) {
    flatbuffers::WriteScalar(&owner_id_, _owner_id);
  }
  int64_t valid_from() const {
    return flatbuffers::EndianScalar(valid_from_);
  }
  void mutate_valid_from(int64_t _valid_from) {
    flatbuffers::WriteScalar(&valid_from_, _valid_from);
  }
};
FLATBUFFERS_STRUCT_END(Policy, 16);

struct GetArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_RETRY = 6
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  bool retry() const {
    return GetField<uint8_t>(VT_RETRY, 0) != 0;
  }
  bool mutate_retry(bool _retry) {
    return SetField<uint8_t>(VT_RETRY, static_cast<uint8_t>(_retry), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_RETRY) &&
           verifier.EndTable();
  }
};

struct GetArgsBuilder {
  typedef GetArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(GetArgs::VT_KEY, key, 0);
  }
  void add_retry(bool retry) {
    fbb_.AddElement<uint8_t>(GetArgs::VT_RETRY, static_cast<uint8_t>(retry), 0);
  }
  explicit GetArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetArgs> CreateGetArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    bool retry = false) {
  GetArgsBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_retry(retry);
  return builder_.Finish();
}

struct GetResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_RETRY = 6,
    VT_VALUE = 8,
    VT_POLICY = 10,
    VT_POLICY_VERSION = 12,
    VT_TIMESTAMP = 14,
    VT_STABLE = 16,
    VT_SUSPICIOUS = 18
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  bool retry() const {
    return GetField<uint8_t>(VT_RETRY, 0) != 0;
  }
  bool mutate_retry(bool _retry) {
    return SetField<uint8_t>(VT_RETRY, static_cast<uint8_t>(_retry), 0);
  }
  const teems::Value *value() const {
    return GetStruct<const teems::Value *>(VT_VALUE);
  }
  teems::Value *mutable_value() {
    return GetStruct<teems::Value *>(VT_VALUE);
  }
  const teems::Policy *policy() const {
    return GetStruct<const teems::Policy *>(VT_POLICY);
  }
  teems::Policy *mutable_policy() {
    return GetStruct<teems::Policy *>(VT_POLICY);
  }
  int64_t policy_version() const {
    return GetField<int64_t>(VT_POLICY_VERSION, 0);
  }
  bool mutate_policy_version(int64_t _policy_version) {
    return SetField<int64_t>(VT_POLICY_VERSION, _policy_version, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(int64_t _timestamp) {
    return SetField<int64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool stable() const {
    return GetField<uint8_t>(VT_STABLE, 0) != 0;
  }
  bool mutate_stable(bool _stable) {
    return SetField<uint8_t>(VT_STABLE, static_cast<uint8_t>(_stable), 0);
  }
  bool suspicious() const {
    return GetField<uint8_t>(VT_SUSPICIOUS, 0) != 0;
  }
  bool mutate_suspicious(bool _suspicious) {
    return SetField<uint8_t>(VT_SUSPICIOUS, static_cast<uint8_t>(_suspicious), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_RETRY) &&
           VerifyField<teems::Value>(verifier, VT_VALUE) &&
           VerifyField<teems::Policy>(verifier, VT_POLICY) &&
           VerifyField<int64_t>(verifier, VT_POLICY_VERSION) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_STABLE) &&
           VerifyField<uint8_t>(verifier, VT_SUSPICIOUS) &&
           verifier.EndTable();
  }
};

struct GetResultBuilder {
  typedef GetResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(GetResult::VT_KEY, key, 0);
  }
  void add_retry(bool retry) {
    fbb_.AddElement<uint8_t>(GetResult::VT_RETRY, static_cast<uint8_t>(retry), 0);
  }
  void add_value(const teems::Value *value) {
    fbb_.AddStruct(GetResult::VT_VALUE, value);
  }
  void add_policy(const teems::Policy *policy) {
    fbb_.AddStruct(GetResult::VT_POLICY, policy);
  }
  void add_policy_version(int64_t policy_version) {
    fbb_.AddElement<int64_t>(GetResult::VT_POLICY_VERSION, policy_version, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(GetResult::VT_TIMESTAMP, timestamp, 0);
  }
  void add_stable(bool stable) {
    fbb_.AddElement<uint8_t>(GetResult::VT_STABLE, static_cast<uint8_t>(stable), 0);
  }
  void add_suspicious(bool suspicious) {
    fbb_.AddElement<uint8_t>(GetResult::VT_SUSPICIOUS, static_cast<uint8_t>(suspicious), 0);
  }
  explicit GetResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetResult> CreateGetResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    bool retry = false,
    const teems::Value *value = 0,
    const teems::Policy *policy = 0,
    int64_t policy_version = 0,
    int64_t timestamp = 0,
    bool stable = false,
    bool suspicious = false) {
  GetResultBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_policy_version(policy_version);
  builder_.add_key(key);
  builder_.add_policy(policy);
  builder_.add_value(value);
  builder_.add_suspicious(suspicious);
  builder_.add_stable(stable);
  builder_.add_retry(retry);
  return builder_.Finish();
}

struct GetTimestampArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetTimestampArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_RETRY = 6
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  bool retry() const {
    return GetField<uint8_t>(VT_RETRY, 0) != 0;
  }
  bool mutate_retry(bool _retry) {
    return SetField<uint8_t>(VT_RETRY, static_cast<uint8_t>(_retry), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_RETRY) &&
           verifier.EndTable();
  }
};

struct GetTimestampArgsBuilder {
  typedef GetTimestampArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(GetTimestampArgs::VT_KEY, key, 0);
  }
  void add_retry(bool retry) {
    fbb_.AddElement<uint8_t>(GetTimestampArgs::VT_RETRY, static_cast<uint8_t>(retry), 0);
  }
  explicit GetTimestampArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetTimestampArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetTimestampArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetTimestampArgs> CreateGetTimestampArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    bool retry = false) {
  GetTimestampArgsBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_retry(retry);
  return builder_.Finish();
}

struct GetTimestampResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetTimestampResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_RETRY = 6,
    VT_POLICY = 8,
    VT_POLICY_VERSION = 10,
    VT_TIMESTAMP = 12,
    VT_SUSPICIOUS = 14
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  bool retry() const {
    return GetField<uint8_t>(VT_RETRY, 0) != 0;
  }
  bool mutate_retry(bool _retry) {
    return SetField<uint8_t>(VT_RETRY, static_cast<uint8_t>(_retry), 0);
  }
  const teems::Policy *policy() const {
    return GetStruct<const teems::Policy *>(VT_POLICY);
  }
  teems::Policy *mutable_policy() {
    return GetStruct<teems::Policy *>(VT_POLICY);
  }
  int64_t policy_version() const {
    return GetField<int64_t>(VT_POLICY_VERSION, 0);
  }
  bool mutate_policy_version(int64_t _policy_version) {
    return SetField<int64_t>(VT_POLICY_VERSION, _policy_version, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(int64_t _timestamp) {
    return SetField<int64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool suspicious() const {
    return GetField<uint8_t>(VT_SUSPICIOUS, 0) != 0;
  }
  bool mutate_suspicious(bool _suspicious) {
    return SetField<uint8_t>(VT_SUSPICIOUS, static_cast<uint8_t>(_suspicious), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_RETRY) &&
           VerifyField<teems::Policy>(verifier, VT_POLICY) &&
           VerifyField<int64_t>(verifier, VT_POLICY_VERSION) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_SUSPICIOUS) &&
           verifier.EndTable();
  }
};

struct GetTimestampResultBuilder {
  typedef GetTimestampResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(GetTimestampResult::VT_KEY, key, 0);
  }
  void add_retry(bool retry) {
    fbb_.AddElement<uint8_t>(GetTimestampResult::VT_RETRY, static_cast<uint8_t>(retry), 0);
  }
  void add_policy(const teems::Policy *policy) {
    fbb_.AddStruct(GetTimestampResult::VT_POLICY, policy);
  }
  void add_policy_version(int64_t policy_version) {
    fbb_.AddElement<int64_t>(GetTimestampResult::VT_POLICY_VERSION, policy_version, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(GetTimestampResult::VT_TIMESTAMP, timestamp, 0);
  }
  void add_suspicious(bool suspicious) {
    fbb_.AddElement<uint8_t>(GetTimestampResult::VT_SUSPICIOUS, static_cast<uint8_t>(suspicious), 0);
  }
  explicit GetTimestampResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetTimestampResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetTimestampResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetTimestampResult> CreateGetTimestampResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    bool retry = false,
    const teems::Policy *policy = 0,
    int64_t policy_version = 0,
    int64_t timestamp = 0,
    bool suspicious = false) {
  GetTimestampResultBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_policy_version(policy_version);
  builder_.add_key(key);
  builder_.add_policy(policy);
  builder_.add_suspicious(suspicious);
  builder_.add_retry(retry);
  return builder_.Finish();
}

struct ProxyGetArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProxyGetArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_CLIENT_ID = 6
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  int32_t client_id() const {
    return GetField<int32_t>(VT_CLIENT_ID, 0);
  }
  bool mutate_client_id(int32_t _client_id) {
    return SetField<int32_t>(VT_CLIENT_ID, _client_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<int32_t>(verifier, VT_CLIENT_ID) &&
           verifier.EndTable();
  }
};

struct ProxyGetArgsBuilder {
  typedef ProxyGetArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(ProxyGetArgs::VT_KEY, key, 0);
  }
  void add_client_id(int32_t client_id) {
    fbb_.AddElement<int32_t>(ProxyGetArgs::VT_CLIENT_ID, client_id, 0);
  }
  explicit ProxyGetArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProxyGetArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProxyGetArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProxyGetArgs> CreateProxyGetArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    int32_t client_id = 0) {
  ProxyGetArgsBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

struct ProxyPutArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProxyPutArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6,
    VT_CLIENT_ID = 8
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  const teems::Value *value() const {
    return GetStruct<const teems::Value *>(VT_VALUE);
  }
  teems::Value *mutable_value() {
    return GetStruct<teems::Value *>(VT_VALUE);
  }
  int32_t client_id() const {
    return GetField<int32_t>(VT_CLIENT_ID, 0);
  }
  bool mutate_client_id(int32_t _client_id) {
    return SetField<int32_t>(VT_CLIENT_ID, _client_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<teems::Value>(verifier, VT_VALUE) &&
           VerifyField<int32_t>(verifier, VT_CLIENT_ID) &&
           verifier.EndTable();
  }
};

struct ProxyPutArgsBuilder {
  typedef ProxyPutArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(ProxyPutArgs::VT_KEY, key, 0);
  }
  void add_value(const teems::Value *value) {
    fbb_.AddStruct(ProxyPutArgs::VT_VALUE, value);
  }
  void add_client_id(int32_t client_id) {
    fbb_.AddElement<int32_t>(ProxyPutArgs::VT_CLIENT_ID, client_id, 0);
  }
  explicit ProxyPutArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProxyPutArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProxyPutArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProxyPutArgs> CreateProxyPutArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    const teems::Value *value = 0,
    int32_t client_id = 0) {
  ProxyPutArgsBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_client_id(client_id);
  builder_.add_value(value);
  return builder_.Finish();
}

struct PutArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PutArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6,
    VT_POLICY = 8,
    VT_POLICY_VERSION = 10,
    VT_TIMESTAMP = 12
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  const teems::Value *value() const {
    return GetStruct<const teems::Value *>(VT_VALUE);
  }
  teems::Value *mutable_value() {
    return GetStruct<teems::Value *>(VT_VALUE);
  }
  const teems::Policy *policy() const {
    return GetStruct<const teems::Policy *>(VT_POLICY);
  }
  teems::Policy *mutable_policy() {
    return GetStruct<teems::Policy *>(VT_POLICY);
  }
  int64_t policy_version() const {
    return GetField<int64_t>(VT_POLICY_VERSION, 0);
  }
  bool mutate_policy_version(int64_t _policy_version) {
    return SetField<int64_t>(VT_POLICY_VERSION, _policy_version, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(int64_t _timestamp) {
    return SetField<int64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<teems::Value>(verifier, VT_VALUE) &&
           VerifyField<teems::Policy>(verifier, VT_POLICY) &&
           VerifyField<int64_t>(verifier, VT_POLICY_VERSION) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct PutArgsBuilder {
  typedef PutArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(PutArgs::VT_KEY, key, 0);
  }
  void add_value(const teems::Value *value) {
    fbb_.AddStruct(PutArgs::VT_VALUE, value);
  }
  void add_policy(const teems::Policy *policy) {
    fbb_.AddStruct(PutArgs::VT_POLICY, policy);
  }
  void add_policy_version(int64_t policy_version) {
    fbb_.AddElement<int64_t>(PutArgs::VT_POLICY_VERSION, policy_version, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(PutArgs::VT_TIMESTAMP, timestamp, 0);
  }
  explicit PutArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PutArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PutArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<PutArgs> CreatePutArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    const teems::Value *value = 0,
    const teems::Policy *policy = 0,
    int64_t policy_version = 0,
    int64_t timestamp = 0) {
  PutArgsBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_policy_version(policy_version);
  builder_.add_key(key);
  builder_.add_policy(policy);
  builder_.add_value(value);
  return builder_.Finish();
}

struct PutResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PutResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_POLICY_VERSION = 6,
    VT_TIMESTAMP = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  int64_t policy_version() const {
    return GetField<int64_t>(VT_POLICY_VERSION, 0);
  }
  bool mutate_policy_version(int64_t _policy_version) {
    return SetField<int64_t>(VT_POLICY_VERSION, _policy_version, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(int64_t _timestamp) {
    return SetField<int64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<int64_t>(verifier, VT_POLICY_VERSION) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct PutResultBuilder {
  typedef PutResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(PutResult::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_policy_version(int64_t policy_version) {
    fbb_.AddElement<int64_t>(PutResult::VT_POLICY_VERSION, policy_version, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(PutResult::VT_TIMESTAMP, timestamp, 0);
  }
  explicit PutResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PutResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PutResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<PutResult> CreatePutResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    int64_t policy_version = 0,
    int64_t timestamp = 0) {
  PutResultBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_policy_version(policy_version);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ChangePolicyResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangePolicyResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_POLICY = 6,
    VT_POLICY_VERSION = 8
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  const teems::Policy *policy() const {
    return GetStruct<const teems::Policy *>(VT_POLICY);
  }
  teems::Policy *mutable_policy() {
    return GetStruct<teems::Policy *>(VT_POLICY);
  }
  int64_t policy_version() const {
    return GetField<int64_t>(VT_POLICY_VERSION, 0);
  }
  bool mutate_policy_version(int64_t _policy_version) {
    return SetField<int64_t>(VT_POLICY_VERSION, _policy_version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<teems::Policy>(verifier, VT_POLICY) &&
           VerifyField<int64_t>(verifier, VT_POLICY_VERSION) &&
           verifier.EndTable();
  }
};

struct ChangePolicyResultBuilder {
  typedef ChangePolicyResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(ChangePolicyResult::VT_KEY, key, 0);
  }
  void add_policy(const teems::Policy *policy) {
    fbb_.AddStruct(ChangePolicyResult::VT_POLICY, policy);
  }
  void add_policy_version(int64_t policy_version) {
    fbb_.AddElement<int64_t>(ChangePolicyResult::VT_POLICY_VERSION, policy_version, 0);
  }
  explicit ChangePolicyResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangePolicyResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangePolicyResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangePolicyResult> CreateChangePolicyResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    const teems::Policy *policy = 0,
    int64_t policy_version = 0) {
  ChangePolicyResultBuilder builder_(_fbb);
  builder_.add_policy_version(policy_version);
  builder_.add_key(key);
  builder_.add_policy(policy);
  return builder_.Finish();
}

struct SmrPropose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmrProposeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_POLICY_READ = 6,
    VT_POLICY = 8,
    VT_SLOT_NUMBER = 10,
    VT_SUSPICIOUS = 12
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  bool policy_read() const {
    return GetField<uint8_t>(VT_POLICY_READ, 0) != 0;
  }
  bool mutate_policy_read(bool _policy_read) {
    return SetField<uint8_t>(VT_POLICY_READ, static_cast<uint8_t>(_policy_read), 0);
  }
  const teems::Policy *policy() const {
    return GetStruct<const teems::Policy *>(VT_POLICY);
  }
  teems::Policy *mutable_policy() {
    return GetStruct<teems::Policy *>(VT_POLICY);
  }
  int64_t slot_number() const {
    return GetField<int64_t>(VT_SLOT_NUMBER, 0);
  }
  bool mutate_slot_number(int64_t _slot_number) {
    return SetField<int64_t>(VT_SLOT_NUMBER, _slot_number, 0);
  }
  bool suspicious() const {
    return GetField<uint8_t>(VT_SUSPICIOUS, 0) != 0;
  }
  bool mutate_suspicious(bool _suspicious) {
    return SetField<uint8_t>(VT_SUSPICIOUS, static_cast<uint8_t>(_suspicious), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_POLICY_READ) &&
           VerifyField<teems::Policy>(verifier, VT_POLICY) &&
           VerifyField<int64_t>(verifier, VT_SLOT_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_SUSPICIOUS) &&
           verifier.EndTable();
  }
};

struct SmrProposeBuilder {
  typedef SmrPropose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(SmrPropose::VT_KEY, key, 0);
  }
  void add_policy_read(bool policy_read) {
    fbb_.AddElement<uint8_t>(SmrPropose::VT_POLICY_READ, static_cast<uint8_t>(policy_read), 0);
  }
  void add_policy(const teems::Policy *policy) {
    fbb_.AddStruct(SmrPropose::VT_POLICY, policy);
  }
  void add_slot_number(int64_t slot_number) {
    fbb_.AddElement<int64_t>(SmrPropose::VT_SLOT_NUMBER, slot_number, 0);
  }
  void add_suspicious(bool suspicious) {
    fbb_.AddElement<uint8_t>(SmrPropose::VT_SUSPICIOUS, static_cast<uint8_t>(suspicious), 0);
  }
  explicit SmrProposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmrPropose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmrPropose>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmrPropose> CreateSmrPropose(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    bool policy_read = false,
    const teems::Policy *policy = 0,
    int64_t slot_number = 0,
    bool suspicious = false) {
  SmrProposeBuilder builder_(_fbb);
  builder_.add_slot_number(slot_number);
  builder_.add_key(key);
  builder_.add_policy(policy);
  builder_.add_suspicious(suspicious);
  builder_.add_policy_read(policy_read);
  return builder_.Finish();
}

struct SmrAccept FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmrAcceptBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOT_NUMBER = 4,
    VT_SUSPICIOUS = 6
  };
  int64_t slot_number() const {
    return GetField<int64_t>(VT_SLOT_NUMBER, 0);
  }
  bool mutate_slot_number(int64_t _slot_number) {
    return SetField<int64_t>(VT_SLOT_NUMBER, _slot_number, 0);
  }
  bool suspicious() const {
    return GetField<uint8_t>(VT_SUSPICIOUS, 0) != 0;
  }
  bool mutate_suspicious(bool _suspicious) {
    return SetField<uint8_t>(VT_SUSPICIOUS, static_cast<uint8_t>(_suspicious), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SLOT_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_SUSPICIOUS) &&
           verifier.EndTable();
  }
};

struct SmrAcceptBuilder {
  typedef SmrAccept Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot_number(int64_t slot_number) {
    fbb_.AddElement<int64_t>(SmrAccept::VT_SLOT_NUMBER, slot_number, 0);
  }
  void add_suspicious(bool suspicious) {
    fbb_.AddElement<uint8_t>(SmrAccept::VT_SUSPICIOUS, static_cast<uint8_t>(suspicious), 0);
  }
  explicit SmrAcceptBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmrAccept> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmrAccept>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmrAccept> CreateSmrAccept(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t slot_number = 0,
    bool suspicious = false) {
  SmrAcceptBuilder builder_(_fbb);
  builder_.add_slot_number(slot_number);
  builder_.add_suspicious(suspicious);
  return builder_.Finish();
}

struct SmrReject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmrRejectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOT_NUMBER = 4,
    VT_SUSPICIOUS = 6
  };
  int64_t slot_number() const {
    return GetField<int64_t>(VT_SLOT_NUMBER, 0);
  }
  bool mutate_slot_number(int64_t _slot_number) {
    return SetField<int64_t>(VT_SLOT_NUMBER, _slot_number, 0);
  }
  bool suspicious() const {
    return GetField<uint8_t>(VT_SUSPICIOUS, 0) != 0;
  }
  bool mutate_suspicious(bool _suspicious) {
    return SetField<uint8_t>(VT_SUSPICIOUS, static_cast<uint8_t>(_suspicious), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SLOT_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_SUSPICIOUS) &&
           verifier.EndTable();
  }
};

struct SmrRejectBuilder {
  typedef SmrReject Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot_number(int64_t slot_number) {
    fbb_.AddElement<int64_t>(SmrReject::VT_SLOT_NUMBER, slot_number, 0);
  }
  void add_suspicious(bool suspicious) {
    fbb_.AddElement<uint8_t>(SmrReject::VT_SUSPICIOUS, static_cast<uint8_t>(suspicious), 0);
  }
  explicit SmrRejectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmrReject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmrReject>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmrReject> CreateSmrReject(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t slot_number = 0,
    bool suspicious = false) {
  SmrRejectBuilder builder_(_fbb);
  builder_.add_slot_number(slot_number);
  builder_.add_suspicious(suspicious);
  return builder_.Finish();
}

struct StabilizeArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StabilizeArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_POLICY_VERSION = 6,
    VT_TIMESTAMP = 8
  };
  int64_t key() const {
    return GetField<int64_t>(VT_KEY, 0);
  }
  bool mutate_key(int64_t _key) {
    return SetField<int64_t>(VT_KEY, _key, 0);
  }
  int64_t policy_version() const {
    return GetField<int64_t>(VT_POLICY_VERSION, 0);
  }
  bool mutate_policy_version(int64_t _policy_version) {
    return SetField<int64_t>(VT_POLICY_VERSION, _policy_version, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(int64_t _timestamp) {
    return SetField<int64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<int64_t>(verifier, VT_POLICY_VERSION) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct StabilizeArgsBuilder {
  typedef StabilizeArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) {
    fbb_.AddElement<int64_t>(StabilizeArgs::VT_KEY, key, 0);
  }
  void add_policy_version(int64_t policy_version) {
    fbb_.AddElement<int64_t>(StabilizeArgs::VT_POLICY_VERSION, policy_version, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(StabilizeArgs::VT_TIMESTAMP, timestamp, 0);
  }
  explicit StabilizeArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StabilizeArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StabilizeArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<StabilizeArgs> CreateStabilizeArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    int64_t policy_version = 0,
    int64_t timestamp = 0) {
  StabilizeArgsBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_policy_version(policy_version);
  builder_.add_key(key);
  return builder_.Finish();
}

struct Greeting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreetingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct GreetingBuilder {
  typedef Greeting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Greeting::VT_ID, id, 0);
  }
  explicit GreetingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Greeting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Greeting>(end);
    return o;
  }
};

inline flatbuffers::Offset<Greeting> CreateGreeting(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0) {
  GreetingBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct Empty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyBuilder {
  typedef Empty Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline flatbuffers::Offset<Empty> CreateEmpty(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TICKET = 6,
    VT_MESSAGE_TYPE = 8,
    VT_MESSAGE = 10
  };
  teems::MessageType type() const {
    return static_cast<teems::MessageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(teems::MessageType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  int64_t ticket() const {
    return GetField<int64_t>(VT_TICKET, 0);
  }
  bool mutate_ticket(int64_t _ticket) {
    return SetField<int64_t>(VT_TICKET, _ticket, 0);
  }
  teems::BasicMessage message_type() const {
    return static_cast<teems::BasicMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const teems::ChangePolicyResult *message_as_ChangePolicyResult() const {
    return message_type() == teems::BasicMessage_ChangePolicyResult ? static_cast<const teems::ChangePolicyResult *>(message()) : nullptr;
  }
  const teems::Greeting *message_as_Greeting() const {
    return message_type() == teems::BasicMessage_Greeting ? static_cast<const teems::Greeting *>(message()) : nullptr;
  }
  const teems::GetArgs *message_as_GetArgs() const {
    return message_type() == teems::BasicMessage_GetArgs ? static_cast<const teems::GetArgs *>(message()) : nullptr;
  }
  const teems::GetResult *message_as_GetResult() const {
    return message_type() == teems::BasicMessage_GetResult ? static_cast<const teems::GetResult *>(message()) : nullptr;
  }
  const teems::GetTimestampArgs *message_as_GetTimestampArgs() const {
    return message_type() == teems::BasicMessage_GetTimestampArgs ? static_cast<const teems::GetTimestampArgs *>(message()) : nullptr;
  }
  const teems::GetTimestampResult *message_as_GetTimestampResult() const {
    return message_type() == teems::BasicMessage_GetTimestampResult ? static_cast<const teems::GetTimestampResult *>(message()) : nullptr;
  }
  const teems::ProxyGetArgs *message_as_ProxyGetArgs() const {
    return message_type() == teems::BasicMessage_ProxyGetArgs ? static_cast<const teems::ProxyGetArgs *>(message()) : nullptr;
  }
  const teems::ProxyPutArgs *message_as_ProxyPutArgs() const {
    return message_type() == teems::BasicMessage_ProxyPutArgs ? static_cast<const teems::ProxyPutArgs *>(message()) : nullptr;
  }
  const teems::PutArgs *message_as_PutArgs() const {
    return message_type() == teems::BasicMessage_PutArgs ? static_cast<const teems::PutArgs *>(message()) : nullptr;
  }
  const teems::PutResult *message_as_PutResult() const {
    return message_type() == teems::BasicMessage_PutResult ? static_cast<const teems::PutResult *>(message()) : nullptr;
  }
  const teems::SmrPropose *message_as_SmrPropose() const {
    return message_type() == teems::BasicMessage_SmrPropose ? static_cast<const teems::SmrPropose *>(message()) : nullptr;
  }
  const teems::SmrAccept *message_as_SmrAccept() const {
    return message_type() == teems::BasicMessage_SmrAccept ? static_cast<const teems::SmrAccept *>(message()) : nullptr;
  }
  const teems::SmrReject *message_as_SmrReject() const {
    return message_type() == teems::BasicMessage_SmrReject ? static_cast<const teems::SmrReject *>(message()) : nullptr;
  }
  const teems::StabilizeArgs *message_as_StabilizeArgs() const {
    return message_type() == teems::BasicMessage_StabilizeArgs ? static_cast<const teems::StabilizeArgs *>(message()) : nullptr;
  }
  const teems::Empty *message_as_Empty() const {
    return message_type() == teems::BasicMessage_Empty ? static_cast<const teems::Empty *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int64_t>(verifier, VT_TICKET) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyBasicMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const teems::ChangePolicyResult *Message::message_as<teems::ChangePolicyResult>() const {
  return message_as_ChangePolicyResult();
}

template<> inline const teems::Greeting *Message::message_as<teems::Greeting>() const {
  return message_as_Greeting();
}

template<> inline const teems::GetArgs *Message::message_as<teems::GetArgs>() const {
  return message_as_GetArgs();
}

template<> inline const teems::GetResult *Message::message_as<teems::GetResult>() const {
  return message_as_GetResult();
}

template<> inline const teems::GetTimestampArgs *Message::message_as<teems::GetTimestampArgs>() const {
  return message_as_GetTimestampArgs();
}

template<> inline const teems::GetTimestampResult *Message::message_as<teems::GetTimestampResult>() const {
  return message_as_GetTimestampResult();
}

template<> inline const teems::ProxyGetArgs *Message::message_as<teems::ProxyGetArgs>() const {
  return message_as_ProxyGetArgs();
}

template<> inline const teems::ProxyPutArgs *Message::message_as<teems::ProxyPutArgs>() const {
  return message_as_ProxyPutArgs();
}

template<> inline const teems::PutArgs *Message::message_as<teems::PutArgs>() const {
  return message_as_PutArgs();
}

template<> inline const teems::PutResult *Message::message_as<teems::PutResult>() const {
  return message_as_PutResult();
}

template<> inline const teems::SmrPropose *Message::message_as<teems::SmrPropose>() const {
  return message_as_SmrPropose();
}

template<> inline const teems::SmrAccept *Message::message_as<teems::SmrAccept>() const {
  return message_as_SmrAccept();
}

template<> inline const teems::SmrReject *Message::message_as<teems::SmrReject>() const {
  return message_as_SmrReject();
}

template<> inline const teems::StabilizeArgs *Message::message_as<teems::StabilizeArgs>() const {
  return message_as_StabilizeArgs();
}

template<> inline const teems::Empty *Message::message_as<teems::Empty>() const {
  return message_as_Empty();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(teems::MessageType type) {
    fbb_.AddElement<int8_t>(Message::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_ticket(int64_t ticket) {
    fbb_.AddElement<int64_t>(Message::VT_TICKET, ticket, 0);
  }
  void add_message_type(teems::BasicMessage message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    teems::MessageType type = teems::MessageType_client_greeting,
    int64_t ticket = 0,
    teems::BasicMessage message_type = teems::BasicMessage_NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline bool VerifyBasicMessage(flatbuffers::Verifier &verifier, const void *obj, BasicMessage type) {
  switch (type) {
    case BasicMessage_NONE: {
      return true;
    }
    case BasicMessage_ChangePolicyResult: {
      auto ptr = reinterpret_cast<const teems::ChangePolicyResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_Greeting: {
      auto ptr = reinterpret_cast<const teems::Greeting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_GetArgs: {
      auto ptr = reinterpret_cast<const teems::GetArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_GetResult: {
      auto ptr = reinterpret_cast<const teems::GetResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_GetTimestampArgs: {
      auto ptr = reinterpret_cast<const teems::GetTimestampArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_GetTimestampResult: {
      auto ptr = reinterpret_cast<const teems::GetTimestampResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_ProxyGetArgs: {
      auto ptr = reinterpret_cast<const teems::ProxyGetArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_ProxyPutArgs: {
      auto ptr = reinterpret_cast<const teems::ProxyPutArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_PutArgs: {
      auto ptr = reinterpret_cast<const teems::PutArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_PutResult: {
      auto ptr = reinterpret_cast<const teems::PutResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_SmrPropose: {
      auto ptr = reinterpret_cast<const teems::SmrPropose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_SmrAccept: {
      auto ptr = reinterpret_cast<const teems::SmrAccept *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_SmrReject: {
      auto ptr = reinterpret_cast<const teems::SmrReject *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_StabilizeArgs: {
      auto ptr = reinterpret_cast<const teems::StabilizeArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BasicMessage_Empty: {
      auto ptr = reinterpret_cast<const teems::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBasicMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBasicMessage(
        verifier,  values->Get(i), types->GetEnum<BasicMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const teems::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<teems::Message>(buf);
}

inline const teems::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<teems::Message>(buf);
}

inline Message *GetMutableMessage(void *buf) {
  return flatbuffers::GetMutableRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<teems::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<teems::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<teems::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<teems::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace teems

#endif  // FLATBUFFERS_GENERATED_TEEMS_TEEMS_H_
